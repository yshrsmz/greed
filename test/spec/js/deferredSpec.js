// Generated by CoffeeScript 1.4.0
(function() {
  var root;

  root = this;

  describe("Deferred", function() {
    var dfr;
    dfr = void 0;
    beforeEach(function() {
      return dfr = new Greed.Deferred();
    });
    it("should exist in Greed", function() {
      expect("Deferred" in window.Greed).toBe(true);
    });
    it("should initialize to state 'pending'", function() {
      expect(dfr.state()).toEqual("pending");
    });
    it("should change its state to 'resolved' when resolved", function() {
      dfr.resolve();
      expect(dfr.state()).toEqual("resolved");
    });
    it("should change its state to 'rejected' when rejected", function() {
      dfr.reject();
      expect(dfr.state()).toEqual("rejected");
    });
    it("should not change state after resolved or rejected", function() {
      dfr.resolve();
      dfr.reject();
      expect(dfr.state()).toEqual("resolved");
      dfr = new Greed.Deferred();
      dfr.reject();
      dfr.resolve();
      expect(dfr.state()).toEqual("rejected");
    });
    it("should execute done & always callbacks after resolving, and not execute fail callbacks", function() {
      var alwaysSpy, doneSpy, failSpy;
      alwaysSpy = jasmine.createSpy();
      doneSpy = jasmine.createSpy();
      failSpy = jasmine.createSpy();
      dfr.done(doneSpy).fail(failSpy).always(alwaysSpy);
      dfr.resolve();
      expect(doneSpy).toHaveBeenCalled();
      expect(failSpy).not.toHaveBeenCalled();
      expect(alwaysSpy).toHaveBeenCalled();
    });
    it("should execute fail & always callbacks after rejecting, and not execute done callbacks", function() {
      var alwaysSpy, doneSpy, failSpy;
      alwaysSpy = jasmine.createSpy();
      doneSpy = jasmine.createSpy();
      failSpy = jasmine.createSpy();
      dfr.done(doneSpy).fail(failSpy).always(alwaysSpy);
      dfr.reject();
      expect(doneSpy).not.toHaveBeenCalled();
      expect(failSpy).toHaveBeenCalled();
      expect(alwaysSpy).toHaveBeenCalled();
    });
    it("should execute done callbacks added with then when resolving", function() {
      var alwaysSpy, doneSpy, failSpy;
      alwaysSpy = jasmine.createSpy();
      doneSpy = jasmine.createSpy();
      failSpy = jasmine.createSpy();
      dfr.then(doneSpy, failSpy);
      dfr.resolve();
      expect(doneSpy).toHaveBeenCalled();
      expect(failSpy).not.toHaveBeenCalled();
    });
    it("should execute fail callbacks added with then when rejecting", function() {
      var alwaysSpy, doneSpy, failSpy;
      alwaysSpy = jasmine.createSpy();
      doneSpy = jasmine.createSpy();
      failSpy = jasmine.createSpy();
      dfr.then(doneSpy, failSpy);
      dfr.reject();
      expect(doneSpy).not.toHaveBeenCalled();
      expect(failSpy).toHaveBeenCalled();
    });
    it("should execute done callbacks when added after resolved, and not execute fail callbacks", function() {
      var alwaysSpy, doneSpy, failSpy;
      alwaysSpy = jasmine.createSpy();
      doneSpy = jasmine.createSpy();
      failSpy = jasmine.createSpy();
      dfr.resolve();
      dfr.done(doneSpy).fail(failSpy).always(alwaysSpy);
      expect(doneSpy).toHaveBeenCalled();
      expect(failSpy).not.toHaveBeenCalled();
      expect(alwaysSpy).toHaveBeenCalled();
    });
    it("should execute fail callbacks when added after rejected, and not execute done callbacks", function() {
      var alwaysSpy, doneSpy, failSpy;
      alwaysSpy = jasmine.createSpy();
      doneSpy = jasmine.createSpy();
      failSpy = jasmine.createSpy();
      dfr.reject();
      dfr.done(doneSpy).fail(failSpy).always(alwaysSpy);
      expect(doneSpy).not.toHaveBeenCalled();
      expect(failSpy).toHaveBeenCalled();
      expect(alwaysSpy).toHaveBeenCalled();
    });
    it("should resolve/reject with context", function() {
      var context;
      context = new Array();
      dfr.done(function() {
        return expect(this).toEqual(context);
      });
      dfr.resolveWith(context);
      dfr = new Greed.Deferred();
      dfr.fail(function() {
        return expect(this).toEqual(context);
      });
      dfr.rejectWith(context);
    });
    it("should resolve with arguments", function() {
      dfr.done(function(firstArg, secondArg) {
        expect(firstArg).toEqual(123);
        expect(secondArg).toEqual("foo");
        expect(this).toEqual(root);
      });
      dfr.resolve(123, "foo");
    });
    it("should reject with arguments", function() {
      dfr.fail(function(firstArg, secondArg) {
        expect(firstArg).toEqual(123);
        expect(secondArg).toEqual("foo");
        expect(this).toEqual(root);
      });
      dfr.reject(123, "foo");
    });
    it("should resolve with context and arguments", function() {
      var context;
      context = new Array();
      dfr = new Greed.Deferred();
      dfr.fail(function(firstArg, secondArg) {
        expect(firstArg).toEqual(123);
        expect(secondArg).toEqual("foo");
        expect(this).toEqual(context);
      });
      dfr.resolveWith(context, 123, "foo");
    });
    it("should reject with context and arguments", function() {
      var context;
      context = new Array();
      dfr = new Greed.Deferred();
      dfr.fail(function(firstArg, secondArg) {
        expect(firstArg).toEqual(123);
        expect(secondArg).toEqual("foo");
        expect(this).toEqual(context);
      });
      dfr.rejectWith(context, 123, "foo");
    });
    describe("Deferred.then() behavior", function() {
      var defer, promise;
      defer = void 0;
      promise = void 0;
      beforeEach(function() {
        defer = new Greed.Deferred();
        return promise = defer.promise();
      });
      it("should let you create a promise", function() {
        expect(promise).toBeDefined();
      });
      it("should call any the promise's handler with the arguments to resolveWith()", function() {
        var handler_args, resolved_args, spyF;
        resolved_args = [1, 2, 3];
        handler_args = void 0;
        spyF = jasmine.createSpy();
        promise.then(function() {
          spyF();
          handler_args = Array.prototype.slice.call(arguments[0], 0);
        });
        defer.resolveWith(defer, resolved_args);
        expect(spyF).toHaveBeenCalled();
        return expect(handler_args).toEqual(resolved_args);
      });
    });
  });

}).call(this);
