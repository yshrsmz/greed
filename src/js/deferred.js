// Generated by CoffeeScript 1.4.0
(function() {
  var __slice = [].slice;

  if (!('Greed' in window)) {
    window.Greed = {};
  }

  (function(Greed) {
    var AP, Deferred, OP, PENDING, REJECTED, RESOLVED, after, execute, flatten, forEach, hasOwn, indexOf, isArguments, isArray, slice, toString, wrap, _g, _when;
    _g = Greed || {};
    AP = Array.prototype;
    OP = Object.prototype;
    hasOwn = OP.hasOwnProperty;
    toString = OP.toString;
    forEach = AP.forEach;
    indexOf = AP.indexOf;
    slice = AP.slice;
    isArray = Array.isArray;
    PENDING = 'pending';
    RESOLVED = 'resolved';
    REJECTED = 'rejected';
    hasOwn = function(obj, prop) {
      return obj != null ? obj.hasOwnProperty(prop) : void 0;
    };
    isArguments = function(obj) {
      return hasOwn(obj, "length") && hasOwn(obj, "callee");
    };
    flatten = function(array) {
      if (isArguments(array)) {
        return flatten(slice.call(array));
      }
      if (!isArray(array)) {
        return [array];
      }
      return array.reduce(function(memo, value) {
        if (isArray(value)) {
          return memo.concat(flatten(value));
        }
        memo.push(value);
        return memo;
      }, []);
    };
    after = function(times, func) {
      if (times <= 0) {
        return func();
      }
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func].concat(slice.call(arguments, 0));
        return wrapper.apply(this, args);
      };
    };
    execute = function(callbacks, args) {
      var callback, _i, _len, _ref, _results;
      _ref = flatten(callbacks);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback.apply(null, args));
      }
      return _results;
    };
    Deferred = (function() {
      var _alwaysCallbacks, _close, _closingArguments, _doneCallbacks, _failCallbacks, _state;

      _state = PENDING;

      _doneCallbacks = [];

      _failCallbacks = [];

      _alwaysCallbacks = [];

      _closingArguments = {};

      _close = function(finalState, callbacks) {
        return function() {
          if (_state === PENDING) {
            _state = finalState;
            _closingArguments = arguments;
            execute([callbacks, _alwaysCallbacks], _closingArguments);
          }
          return this;
        };
      };

      function Deferred() {
        this.promise(this);
        this.when = _when;
        return this;
      }

      Deferred.prototype.resolve = _close(RESOLVED, _doneCallbacks);

      Deferred.prototype.reject = _close(REJECTED, _failCallbacks);

      Deferred.prototype.resolveWith = function() {
        var args, context;
        context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return execute([_doneCallbacks, _alwaysCallbacks], args, context);
      };

      Deferred.prototype.rejectWith = function() {
        var args, context;
        context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return execute([_failCallbacks, _alwaysCallbacks], args, context);
      };

      Deferred.prototype.promise = function(candidate) {
        var storeCallbacks, _pipe;
        candidate = candidate || {};
        candidate.state = _state;
        storeCallbacks = function(shouldExecuteNow, holder) {
          return function() {
            if (_state === PENDING) {
              holder.push(flatten.apply(null, arguments));
            }
            if (shouldExecuteNow) {
              execute(arguments, _closingArguments);
            }
          };
        };
        _pipe = function(doneFilter, failFilter) {
          var deferred, _filter;
          deferred = new Deferred();
          _filter = function(target, source, filter) {
            if (filter) {
              return target(function() {
                return source(filter.apply(null, flatten(arguments)));
              });
            } else {
              return target(function() {
                return source.apply(null, flatten(arguments));
              });
            }
          };
          _filter(candidate.done, deferred.resolve, doneFilter);
          _filter(candidate.dail, deferred.reject, failFilter);
          return deferred;
        };
        candidate.done = storeCallbacks(_state === RESOLVED, _doneCallbacks);
        candidate.fail = storeCallbacks(_state === REJECTED, _failCallbacks);
        candidate.always = storeCallbacks(_state !== PENDING, _alwaysCallbacks);
        candidate.pipe = _pipe;
        candidate.then = _pipe;
        return candidate;
      };

      return Deferred;

    })();
    _when = function() {
      var def, defs, finish, trigger, _i, _j, _len, _len1;
      trigger = new Deferred();
      defs = flatten(arguments);
      finish = after(defs.length, trigger.resolve);
      for (_i = 0, _len = defs.length; _i < _len; _i++) {
        def = defs[_i];
        def.done(finish);
      }
      for (_j = 0, _len1 = defs.length; _j < _len1; _j++) {
        def = defs[_j];
        def.fail(trigger.reject());
      }
      return trigger.promise();
    };
    _g.Deferred = function() {
      return new Deferred();
    };
    _g.Deferred.when = _when;
    _g.when = _when;
  })(Greed);

  /*
  do (Greed) ->
      _g = Greed
      class Promise
          constructor: ->
              console.log 'Promise constructor'
              return {
                  when: (func) ->
                      @vouch @STATUS_FULFILLED, func
                      return @
                  fail: (func) ->
                      @vouch @STATUS_SMASHED, func
                      return @
                  fulfill: (value) ->
                      @resolve @STATUS_FULFILEED, value
                      return @
                  smash: (string) ->
                      @resolve @STATUS_SMASHED, string
                      return @
                  status: ->
                      @status
                  promise: ->
                      return {
                          when: @when
                          fail: @fail
                      }
              }
              
          STATUS_UNRESOLVED: 'unresolved'
          STATUS_FULFILLED: 'fulfilled'
          STATUS_SMASHED: 'smashed'
          status: @STATUS_UNRESOLVED
          waiting: []
          dreading: []
          always: []
          outcome: undefined
          vouch: (deed, func) ->
              switch status
                  when 'unresolved'
                      (if deed is 'fulfilled' then @waiting else @dreading).push func
                  when deed
                      func @outcome
              null
          resolve: (deed, value) ->
              if @status isnt 'unresolved'
                  throw new Error "The promise has already been resolved: #{@status}"
              
              @status = deed
              @outcome = value
              for func in (if deed is @STATUS_FULFILLED then @waiting else @dreading)
                  try
                      func @outcome
                  catch error
                      console.log "error: #{error}"
              
              @waiting = null
              @dreading = null
          
              return
          
      _g.Promise = Promise
  */


}).call(this);
